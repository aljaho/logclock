<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Logarithmic Clock</title>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<style>
    body {
        margin: 0;
        background: white;
        overflow: hidden;
    }
    canvas {
        display: block;
    }
    #backButton {
        position: absolute;
        top: 10px;
        left: 10px;
        background: #ddd;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 16px;
        text-decoration: none;
        color: black;
    }
</style>
</head>
<body>
<a id="backButton" href="index.html">&#8592; Back</a>
<canvas id="clock"></canvas>

<script>
const canvas = document.getElementById("clock");
const ctx = canvas.getContext("2d");

const pageBgColor = localStorage.getItem("pageBgColor") || "#f0f0f0";

// Haetaan asetukset index.html:stä
let bgWood = localStorage.getItem("bgWood") === "true";
let bgColor = localStorage.getItem("bgColor") || "#ffffff";
let bgImageSrc = localStorage.getItem("bgImage") || "log_cross-section.png";
let minColor = localStorage.getItem("minColor") || "#7e5f51";
let hourColor = localStorage.getItem("hourColor") || "black";
let fontFamily = localStorage.getItem("fontFamily") || "Arial";
let scaleBorderColor = localStorage.getItem("scaleBorderColor") || "black"; // Lisätty

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
document.body.style.backgroundColor = pageBgColor;
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

function rotatePoint(x, y, cx, cy, angle) {
    const dx = x - cx;
    const dy = y - cy;
    const rx = dx * Math.cos(angle) - dy * Math.sin(angle);
    const ry = dx * Math.sin(angle) + dy * Math.cos(angle);
    return [cx + rx, cy + ry];
}

function drawOuterScale(cx, cy, radius) {
    ctx.lineCap = "round";
    const hourFontSize = radius * 0.12;
    const minuteFontSize = radius * 0.07;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    const rotationOffset = (1 - Math.log(12) / Math.log(13)) * 2 * Math.PI;
    for (let t = 1; t < 13; t += 0.2) {
        const angle = Math.log(t) / Math.log(13) * 2 * Math.PI + rotationOffset;
        const outerR = radius;
        const innerR = radius - radius * 0.07;

        // viivat
        ctx.beginPath();
        const [x1, y1] = rotatePoint(cx, cy - outerR, cx, cy, angle);
        const [x2, y2] = rotatePoint(cx, cy - innerR, cx, cy, angle);
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineWidth = (Math.abs(t - Math.round(t)) < 0.001) ? 2.5 : 1;
        ctx.strokeStyle = scaleBorderColor; // Muutettu
        ctx.stroke();

        if (Math.abs(t - Math.round(t)) < 0.001) {
            const hourNum = Math.round(t) === 13 ? 1 : Math.round(t);
            let minuteValue = (hourNum % 12) * 5;
            if (minuteValue === 0) minuteValue = 60;

            // minuuttiluku ulommalle
            const [tmx, tmy] = rotatePoint(cx, cy - (outerR - radius * 0.13), cx, cy, angle);
            ctx.font = `${minuteFontSize}px ${fontFamily}`;
            const metricsM = ctx.measureText(minuteValue.toString());
            const paddingM = 3;
            const rectWidthM = metricsM.width + paddingM * 2;
            const rectHeightM = minuteFontSize + paddingM * 2;
            ctx.fillStyle = bgWood ? "#f4e3cb" : bgColor;
            ctx.beginPath();
            ctx.ellipse(tmx, tmy, rectWidthM / 2, rectHeightM / 2, 0, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = minColor;
            ctx.fillText(minuteValue.toString(), tmx, tmy);

            // tuntinumero sisemmälle
            const [tx, ty] = rotatePoint(cx, cy - (outerR - radius * 0.24), cx, cy, angle);
            ctx.font = `${hourFontSize}px ${fontFamily}`;
            const metricsH = ctx.measureText(hourNum.toString());
            const paddingH = 4;
            const rectWidthH = metricsH.width + paddingH * 2;
            const rectHeightH = hourFontSize + paddingH * 2;
            ctx.fillStyle = bgWood ? "#f4e3cb" : bgColor;
            ctx.beginPath();
            ctx.ellipse(tx, ty, rectWidthH / 2, rectHeightH / 2, 0, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = hourColor;
            ctx.fillText(hourNum.toString(), tx, ty);
        }
    }
}

function rotatePolygon(points, cx, cy, angle) {
    const rotated = [];
    for (let i = 0; i < points.length; i += 2) {
        const [x, y] = rotatePoint(points[i], points[i+1], cx, cy, angle);
        rotated.push(x, y);
    }
    return rotated;
}

function drawHand(points, cx, cy, angle, color) {
    const rotated = rotatePolygon(points, cx, cy, angle);
    ctx.beginPath();
    ctx.moveTo(rotated[0], rotated[1]);
    for (let i = 2; i < rotated.length; i += 2) {
        ctx.lineTo(rotated[i], rotated[i+1]);
    }
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.strokeStyle = color;
    ctx.fill();
    ctx.stroke();
}

const bgImage = new Image();
bgImage.src = bgImageSrc;

function drawClock() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    const radius = Math.min(canvas.width, canvas.height) * 0.4;

    // taustakuva tai väri
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
    ctx.clip();
    if (bgWood && bgImage.complete) {
        const imgRatio = bgImage.width / bgImage.height;
        const targetDiameter = radius * 2;
        let drawWidth, drawHeight;
        if (imgRatio > 1) {
            drawHeight = targetDiameter;
            drawWidth = targetDiameter * imgRatio;
        } else {
            drawWidth = targetDiameter;
            drawHeight = targetDiameter / imgRatio;
        }
        const dx = cx - drawWidth / 2;
        const dy = cy - drawHeight / 2;
        ctx.drawImage(bgImage, dx, dy, drawWidth, drawHeight);
    } else {
        ctx.fillStyle = bgColor;
        ctx.fillRect(cx - radius, cy - radius, radius * 2, radius * 2);
    }
    ctx.restore();

    // asteikko
    drawOuterScale(cx, cy, radius);

    const rotationOffset = (1 - Math.log(12) / Math.log(13)) * 2 * Math.PI;

    // viisarien muodot
    const secShape = [cx, cy, cx, cy - radius*0.965];
    const minShape = [
        cx, cy + radius*0.03,
        cx + radius*0.03, cy,
        cx, cy - radius*0.965,
        cx - radius*0.03, cy
    ];
    const hourShape = [
        cx, cy + radius*0.03,
        cx + radius*0.03, cy,
        cx, cy - radius*0.65,
        cx - radius*0.03, cy
    ];

    const now = new Date();

    let rawSeconds = now.getSeconds() + now.getMilliseconds() / 1000;
    let seconds = rawSeconds < 5 ? rawSeconds + 60 : rawSeconds;
    const secAngle = Math.log(seconds / 5) / Math.log(13) * 2 * Math.PI + rotationOffset;
    drawHand(secShape, cx, cy, secAngle, minColor);

    let rawMinutes = now.getMinutes() + rawSeconds / 60;
    let minutes = rawMinutes < 5 ? rawMinutes + 60 : rawMinutes;
    const minAngle = Math.log(minutes / 5) / Math.log(13) * 2 * Math.PI + rotationOffset;
    drawHand(minShape, cx, cy, minAngle, minColor);

    let hoursRaw = (now.getHours() % 12) + rawMinutes / 60;
    let hours = hoursRaw < 1 ? hoursRaw + 12 : hoursRaw;
    const hourAngle = Math.log(hours) / Math.log(13) * 2 * Math.PI + rotationOffset;
    drawHand(hourShape, cx, cy, hourAngle, hourColor);

    // ulkokehys
    ctx.beginPath();
    ctx.arc(cx, cy, radius + 6, 0, 2 * Math.PI);
    ctx.lineWidth = 16;
    ctx.strokeStyle = scaleBorderColor; // Muutettu
    ctx.stroke();

    requestAnimationFrame(drawClock);
}

drawClock();
</script>
</body>
</html>
